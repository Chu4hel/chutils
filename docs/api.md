# Справочник API

В этом разделе находится документация, автоматически сгенерированная из исходного кода `chutils`.

## Пакет `chutils`

::: chutils
options:
members: [init]

## Модуль `config`

::: chutils.config
options:
members:

- get_config
- get_config_value
- get_config_int
- get_config_float
- get_config_boolean
- get_config_list
- get_config_section
- save_config_value

### Переопределение конфигурации локальным файлом

Функция `get_config()` теперь автоматически ищет и загружает локальный файл конфигурации (например, `config.local.yml`
или `config.local.ini`) в той же директории, что и основной файл (`config.yml` или `config.ini`). Значения из локального
файла **переопределяют** соответствующие значения из основного файла.

Это позволяет удобно управлять чувствительными или специфичными для разработчика настройками, не коммитя их в
репозиторий.

**Пример:**

Если `config.yml` содержит:

```yaml
# config.yml
Database:
  host: production_db.com
  port: 5432
App:
  debug: false
```

А `config.local.yml` содержит:

```yaml
# config.local.yml
Database:
  host: localhost
App:
  debug: true
  developer_mode: true
```

Тогда `get_config()` вернет объединенную конфигурацию, где локальные настройки переопределяют основные:

```python
{
    "Database": {
        "host": "localhost",  # Переопределено локальным файлом
        "port": 5432  # Взято из основного файла
    },
    "App": {
        "debug": True,  # Переопределено локальным файлом
        "developer_mode": True  # Добавлено из локального файла
    }
}
```

**Важно:** Убедитесь, что вы добавили `config.local.yml` (или `config.local.ini`) в ваш `.gitignore`, чтобы случайно
не закоммитить локальные или чувствительные настройки.

## Модуль `logger`

::: chutils.logger
options:
members:

- setup_logger
- ChutilsLogger
- DEVDEBUG_LEVEL_NUM
- MEDIUMDEBUG_LEVEL_NUM

### Расширенная настройка логгера: управление уровнем, ротацией и сжатием

Функция `setup_logger` предлагает гибкую настройку логгеров, включая управление уровнем логирования, ротацией файлов и
их сжатием.

**Ключевые особенности и изменения:**

* **Динамическое обновление уровня логирования:** При каждом вызове `setup_logger` для существующего логгера его уровень
  логирования **всегда обновляется** до указанного или настроенного значения.
* **Гибкий `log_level`:** Параметр `log_level` теперь может принимать как объекты `LogLevel` (например,
  `LogLevel.INFO`), так и их строковое представление (например, `"INFO"`, `"DEBUG"`). Это позволяет удобно задавать
  уровень как через код, так и через конфигурационные файлы.
* **Идемпотентная настройка обработчиков:** Обработчики логов (для консоли и файлов) настраиваются только при первом
  вызове для данного логгера. При последующих вызовах обработчики не пересоздаются, если только не указан флаг
  `force_reconfigure=True`. Это предотвращает дублирование обработчиков и обеспечивает эффективную работу.
* **Расширенные опции ротации и сжатия:** Поддерживаются различные типы ротации (по времени или по размеру), а также
  автоматическое сжатие ротированных файлов в `.gz` для экономии места. Эти параметры могут быть заданы как напрямую в
  вызове `setup_logger`, так и через конфигурационный файл `config.yml` в секции `Logging`.

**Параметры ротации:**

* `rotation_type` (строка): Определяет тип ротации.
    * `'time'` (по умолчанию): Ротация происходит по времени (например, ежедневно).
    * `'size'`: Ротация происходит, когда файл лога достигает определенного размера.
* `max_bytes` (целое число): Максимальный размер файла лога в байтах. Используется только если `rotation_type`
  установлен в `'size'`. При достижении этого размера файл будет ротирован. Значение `0` означает отсутствие лимита по
  размеру.
* `compress` (булево): Если `True`, ротированные файлы логов будут автоматически сжиматься в формат `.gz`. Это помогает
  экономить место на диске.
* `backup_count` (целое число): Количество ротированных файлов логов, которые будут храниться. Старые файлы, превышающие
  это количество, будут удаляться.

#### Гибкая настройка логгеров через конфигурацию: параметр `config_section_name`

Теперь `setup_logger` позволяет гибко управлять настройками разных логгеров через конфигурационный файл, используя
параметр `config_section_name`.

**Приоритет настроек:**

1. **Аргументы функции**: Значения, переданные напрямую в `setup_logger` (например, `log_level=...`), имеют
   наивысший приоритет.
2. **Секция, указанная в `config_section_name`**: Если в `setup_logger` передан параметр
   `config_section_name="MyLogger"`, то настройки будут искаться в секции `[MyLogger]` (например, `[AuditLogger]` или
   `[EventLogger]`).
3. **Общая секция `[Logging]`**: Если настройка не найдена в специфичной секции (или та не указана), поиск
   происходит в общей секции `[Logging]`. Она служит для задания настроек по умолчанию для всех логгеров.
4. **Встроенные значения**: Если настройка не найдена нигде, используется жестко заданное в коде значение
   (например, `rotation_type='time'`).

**Пример конфигурации (`config.yml`):**

```yaml
# config.yml

# Общая секция, задает настройки по умолчанию для всех логгеров
Logging:
  log_level: INFO
  rotation_type: time
  compress: true
  log_backup_count: 5

# Специфичная секция для логгера аудита
AuditLogger:
  log_level: DEBUG           # Переопределяет log_level из [Logging]
  log_file_name: "audit.log" # Задает уникальное имя файла
  log_backup_count: 30       # Переопределяет log_backup_count из [Logging]

# Специфичная секция для логгера событий
EventLogger:
  log_file_name: "events.log"
  rotation_type: size        # Переопределяет тип ротации
  max_bytes: 10485760        # 10 МБ
```

**Примеры использования в коде:**

```python
from chutils import setup_logger

# 1. Логгер с настройками по умолчанию из секции [Logging]
# Так как config_section_name не указан, используется только [Logging].
main_logger = setup_logger("main_app")
main_logger.info("Это сообщение от основного логгера.")  # Уровень INFO

# 2. Логгер аудита со специфичными настройками
# Явно указываем, что нужно прочитать секцию [AuditLogger]
audit_logger = setup_logger("audit", config_section_name="AuditLogger")
audit_logger.debug("Это отладочное сообщение для аудита.")  # Уровень DEBUG

# 3. Логгер событий со своими настройками
event_logger = setup_logger("events", config_section_name="EventLogger")
event_logger.info("Логгер событий использует ротацию по размеру.")  # Уровень INFO из [Logging]

# 4. Явное переопределение аргументом функции (высший приоритет)
# Уровень будет WARNING, несмотря на настройки в config.yml
important_logger = setup_logger("important", log_level="WARNING")
```

**Примеры использования:**

**1. Ротация по размеру со сжатием:**

Чтобы настроить логгер, который ротирует файлы при достижении 1 МБ и сжимает старые бэкапы, используйте:

```python
from chutils import setup_logger

logger = setup_logger(
    "my_app_size_rotated",
    log_file_name="app_size.log",
    rotation_type='size',
    max_bytes=1048576,  # 1 МБ
    compress=True,
    backup_count=5
)
logger.info("Это сообщение будет записано в файл app_size.log, который будет ротироваться по размеру и сжиматься.")
```

**2. Ежедневная ротация со сжатием (по умолчанию):**

Для ежедневной ротации со сжатием (это поведение по умолчанию, если `rotation_type` не указан или равен `'time'`):

```python
from chutils import setup_logger

logger = setup_logger(
    "my_app_time_rotated",
    log_file_name="app_time.log",
    rotation_type='time',  # Можно опустить, так как это значение по умолчанию
    compress=True,
    backup_count=7
)
logger.info("Это сообщение будет записано в файл app_time.log, который будет ротироваться ежедневно и сжиматься.")
```

**3. Настройка через `config.yml`:**

Вы также можете управлять этими параметрами через ваш `config.yml`:

```yaml
# config.yml
Logging:
  log_level: INFO
  log_file_name: app.log
  rotation_type: size      # Или 'time'
  max_bytes: 5242880       # 5 МБ, если rotation_type: size
  compress: true           # Сжимать ротированные файлы
  log_backup_count: 10     # Хранить 10 бэкапов
```

При такой конфигурации вызов `setup_logger()` без явных параметров автоматически применит эти настройки:

```python
from chutils import setup_logger

logger = setup_logger("my_app")
logger.info("Настройки ротации и сжатия взяты из config.yml.")
```

### Пример создания нескольких логгеров

Вы можете создавать разные логгеры для разных частей вашего приложения, передавая уникальное имя в `setup_logger`.
Параметр `log_file_name` позволяет указать отдельный файл для каждого логгера, что помогает фильтровать и разделять
логи.

```python
# main.py
from chutils import setup_logger

# Основной логгер приложения будет писать в main_app.log
main_logger = setup_logger("main_app", log_file_name="main_app.log")
# Логгер для модуля, отвечающего за работу с базой данных, будет писать в database.log
db_logger = setup_logger("database", log_file_name="database.log")

main_logger.info("Приложение запущено.")
db_logger.debug("Инициализация подключения к БД...")
```

В лог-файлах вы увидите сообщения от соответствующих логгеров.
Более подробный пример можно найти в файле `examples/05_different_log_levels.py`.

## Модуль `secret_manager`

::: chutils.secret_manager

### Конфигурация SecretManager и предотвращение конфликтов

Для безопасной работы с `keyring` крайне важно, чтобы каждое приложение использовало уникальное имя сервиса (
`service_name`). Это предотвращает конфликты, когда два разных приложения могут случайно перезаписать секреты друг
друга.

`SecretManager` определяет `service_name` по следующему приоритету:

1. **Значение, переданное в конструктор**:
   ```python
   from chutils import SecretManager
   # Явное указание имени сервиса (наивысший приоритет)
   secrets = SecretManager("my-super-unique-app-name")
   ```

2. **Значение из конфигурационного файла**: Если `service_name` не передан в конструктор (или передан пустым),
   `SecretManager` попытается найти его в вашем `config.yml` файле в секции `Secrets`.
   ```yaml
   # config.yml
   Secrets:
     service_name: my-super-unique-app-name
     prefix: "WebApp_" # Опционально, можно переопределить префикс
   ```
   В этом случае `SecretManager` можно инициализировать без аргументов:
   ```python
   from chutils import SecretManager
   # Имя будет взято из config.yml
   secrets = SecretManager()
   ```

3. **Абсолютный путь к проекту (поведение по умолчанию)**: Если имя не найдено ни в конструкторе, ни в конфигурации,
   `SecretManager` автоматически использует **абсолютный путь к корню вашего проекта** в качестве `service_name`.
   > Это гарантирует, что `service_name` будет уникальным для каждого проекта, предотвращая конфликты по умолчанию без
   необходимости ручной настройки.

**Префикс**

Итоговое имя сервиса в `keyring` формируется как `prefix + service_name`. Префикс также можно настроить. Порядок
приоритета для префикса:

1. Значение, переданное в конструктор.
2. Значение из `config.yml` (секция `Secrets`, ключ `prefix`).
3. Значение по умолчанию: `"Chutils_"`.